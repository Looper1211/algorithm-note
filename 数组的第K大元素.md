# 数组的第K大元素
>给出数组 [9,3,2,4,8]，第三大的元素是 4 给出数组 [1,2,3,4,5]，第一大的元素是 5，第二大的元素是 4，第三大的元素是 3，以此类推

### 1. 直接排序
最简单的想法是直接进行排序，最优的排序算法复杂度是$O(n\log_2n)$。这么做很明显比较低效率，因为不要求别的信息只要计算出第K大的元素。

我们也可以用选择、冒泡等通过比较，交换位置的排序，但是这种算法并不是最快的排序算法，计算出最大（小）的元素的算法复杂度是$O(n)$。这个过程不能中断，要计算第三大的元素必须建立在已经算出第二大的元素的基础上，所以它的算法复杂度是$O(n*k)$;

当然，如果在某种情况下需要频繁访问第K大的元素就可以先进行一次排序在直接得出结果

### 2. 优先队列
其实就是可以利用堆排序的思想，对大小为N的数组构建二叉堆的算法复杂度是$O(N)$。然后每次下滤的算法复杂度是$O(\log_2 N)$，一共下滤K次，算法复杂度是$O(N+K\log_2 N)$

### 3. 随机快速排序-期望线性时间
利用快排的思想，随机选择一个数进行划分，将数组化分为区间$S_1$(大于等于区)和$S_2$(小于区),计算出$S_1$的区间长度$l$

* 如果$l > k$,那就在$S_1$区间再进行划分
* 如果$l < k$,那就在$S_1$的区间找第$k-l$大元素
* 如果 $l = k$，$S_1$的最后一个元素就是我们要找的第k大元素的值

```python
import random


def swap(arr, x, y):
    arr[x], arr[y] = arr[y], arr[x]


def partation(arr, l, r, key):
    """
    划分区间，分为大于等于区和小于区
    :param arr: 
    :param l: 
    :param r: 
    :param key: 
    :return: 大于等于区的最后一个位置 和 大于等于区的长度
    """
    more = l - 1
    less = r + 1
    temp = l
    while l < less:
        if arr[l] > key:
            more += 1
            swap(arr, more, l)
            l += 1
        elif arr[l] < key:
            less -= 1
            swap(arr, less, l)
        else:
            l += 1
    return less - 1, less - temp


def find_kth(arr, l, r, k):
    if l <= r:
        # 根据随机算法产生一个划分值
        key = arr[random.randint(l, r)]
        p = partation(arr, l, r, key)
        # 如果大于等于长度 大于 k，就在大于等于区上继续查找
        if p[1] > k:
            # 注意：子问题规模必须减少1，否则可能堆栈溢出
            return find_kth(arr, l, p[0] - 1, k)
        # 如果大于等于长度 小于 k，就在小于区上查找 k-p[1]的值
        elif p[1] < k:
            return find_kth(arr, p[0] + 1, r, k - p[1])
        else:
            return arr[p[0]]
```
这里有一个地方需要注意，可能会出现极端划分情况，比如[1,2,3,4,5]，如果按照1进行划分，大于等于区的范围和原数组范围一致，此时子问题的规模并没有减少，所以必须强制减少子问题的规模

##### 时间复杂度估算
n个元素，划分后左边刚好有K个元素的概率：1/n
利用指示随机变量：
$$X_k=I\left \{左边刚好有k个元素\right \}$$
假定元素的值不相同，因此有：
$$E[X_k]=1/n$$
所以时间复杂度可以表示为：
$$
T(n)<=\sum_{k=1}^{n}X_k\cdot [T(max(k-1,n-k))+O(n)]\\\
=\sum_{k=1}^{n}X_k\cdot T(max(k-1,n-k))+ O(n)
$$
取期望值，得到：
$$E[T(n)]=\sum_{k=1}^{n}E[X_k\cdot T(max(k-1,n-k))]+O(n)\\
$$
由于$X_k和T(max(n-k,k-1))互相独立$，因此
$$
E[T(n)]=\sum_{k=1}^{n}E[X_k]\cdot E[T(max(k-1,n-k))]+O(n)\\
=\sum_{k=1}^{n}\frac{1}{n} \cdot E[T(max(k-1,n-k))]+O(n)
$$

对于$max(k-1,n-k)$，可以有以下表达式：

* $max(k-1,n-k)=k-1    (k>[n/2])$
* $max(k-1,n-k)=n-k    (k<=[n/2])$

如果n是偶数，从T(n/2)到T(n-1)的每一项在总和中刚好出现了两次，对于n为奇数，这些项都会出现两次，而T(n/2)出现一次，因此：
$$
E[T(n)]<=\frac{2}{n}\sum_{k=n/2}^{n}E[T(k)]+O(n)
$$

通过数学归纳和替换法，可以得出
$$E[T(n)]=O(n)$$
可以得出结论：**在平均情况下，任何顺序统计量都可以在线性时间内得到**














