# 无处不在的二分
> 《编程珠玑》第二章问题A 是这样描述的：
> 给定一个最多包含40亿个随机排列的32位整数的顺序文件，找出一个不在文件中的32位整数。

> 1. 在具有足够内存的情况下，如何解决问题？
> 2. 如何有几个外部“临时”文件可用，但是仅有几百字节的内存，又该如何解决该问题？

### 1. 位图法
32位整数，包括-2146473648~~2146473647，约42亿个整数，而文件中只有40亿个，必然有整数少了。
我们可以采用位数思想来存放，则32位整数最多需要占用43亿个位。约512MB的内存空间  (2^32 /8=512MB，这种情况是用一个位表示8bit)

我们遍历一遍文件，将出现的数对应的那一位置为1，然后遍历这些位，找到第一个有0的位即可，这一位对应的数没有出现。

这里可以借助Redis的位图，关于其官方介绍如下：

>位图不是一个真实的数据类型，而是定义在字符串类型上的面向位的操作的集合。由于字符串类型是二进制安全的二进制大对象，并且最大长度是 512MB，适合于设置 2^32个不同的位。
位操作分为两组：常量时间单个位的操作，像设置一个位为 1 或者 0，或者获取该位的值。对一组位的操作，例如计算指定范围位的置位数量。

简而言之，位图操作是用来操作比特位的，其优点是节省内存空间。

```python
import redis
def get_lost(data):
    conn = redis.StrictRedis(host="127.0.0.1", port=6379, charset="utf-8")
    redis_key = "lost_data"
    for x in data:
        conn.setbit(redis_key, x, 1)

    for x in range(1, 1 << 32):
        if conn.getbit(redis_key, x) == 0:
            return x
```
时间复杂度:$O(n)$

### 2. 无所不能的二分
可以根据某一位（操作时，可以从最高位 到 最低位依次处理），把待处理的数据分成两部分。在一部分中，此位为0，另一部分此位为1。

之后，分别统计落在两个部分的数的个数。（此时我们不考虑数据是否重复）

* 如果没有缺失，那么这两部分数的个数应该是相等的。
* 如果数据有缺失，那么两部分数可能相等，也可能不等
    * 两部分相等的情况：两段都缺失，但缺失的个数相等
    * 两部分不等的情况：一个缺一个不缺  或  都缺但缺的个数不同 

基于此，把数据分成两部分后，我们可以去数据量小的那个部分寻找缺失的数。如果两个部分的数相等，我们可以随意选择一个部分寻找缺失的数据。此时，可以递归的处理紧挨着的下一位。直到遍历完所有的位后，就可以找到一个缺失的数

```python
def get_lost(data, max_bit):
    res = 0
    lens = len(data)
    list_0 = [0] * lens
    list_1 = [0] * lens
    for bit in range(max_bit - 1, -1, -1):
        check_num = 1 << bit
        index_1 = 0
        index_0 = 0
        for i in range(lens):
            if data[i] & check_num:
                list_1[index_1] = data[i]
                index_1 += 1
            else:
                list_0[index_0] = data[i]
                index_0 += 1

        if index_1 < index_0:
            res += check_num
            data = list_1
            lens = index_1
        else:
            data = list_0
            lens = index_0
    return res

data = [0, 1, 2, 4, 5, 6, 7]
print(get_lost(data, 3))
```
这种查找方法的时间复杂度是$O(n),n+n/2+n/4+n/8+n/2^{\log_2 n}=2n-1$;故时间复杂度是$O(n)$，总共划分的次数是$\log_2 n$ 。


