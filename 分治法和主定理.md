# 分治法和主定理
注：文中相关定理信息来源于MIT的《算法导论》,本文只讨论利用主定理进行分治法的复杂度分析

### 分治法 Divide and Conquer
分治法包含三个部分

* 分 Divide
* 治 Conquer
* 合 merge

分的过程可以用递归实现，而且不是分一次就结束了，分后的子问题，也会被看做一个完整的问题，再进行分解子问题，只有这样，才能降低算法的复杂度

### 主定理 Master Theorem
其实也可以称作：递归算法的复杂度判定定理

基本公式：
$$T(问题规模)=子问题数*T(子问题规模)+额外计算$$
数学上的表现形式如下：
$$T(n)=a*T(n/b)+f(n)$$
直接计为：
$$T(n)=a*T(n/b)+\Theta(n^d)$$

其中$ a >= 1 $ 并且 $b > 1 $是常量，其表示的意义是 n 表示问题的规模，a 表示递归的次数也就是生成的子问题规模数，b 表示每次递归是原来的$1/b$的规模，$f(n)$表示分解和合并所要花费的时间之和。

解法如下：

* 如果 $d<\log_b a$，时间复杂度为$\Theta(n^{\log_b a})$
* 如果 $d=\log_b a$，时间复杂度为$\Theta(n^d*\log_2 n)$
* 如果 $d>\log_b a$，时间复杂度为$\Theta(n^d)$

### 分治法举例
#### 1. 归并排序（二路）Merge Sort
分成两个子序列，子序列排序，合并两个子序列
$$T(n)=2T(n/2)+\Theta(n)$$
利用主定理公式求解：
$$T(n)=\Theta(n\log_2 n)$$

#### 2. 二分查找
有序序列中，先和序列中点比较，选择结果的位置，然后再从子序列中查找，并迭代这样的过程
$$T(n)=T(n/2)+\Theta(1)$$
套用Master公式，可得：
$$T(n)=\Theta(\log_2 n)$$

#### 3. Fibonacci
斐波那契无法直接使用分治法求解，不过其计算公式可以使用分治法求值,关于公式的推导参见[从Fibonacci数列开始](mweblib://15372005924904)
$$T(n)=\Theta(\log_2 n)$$

#### 4. 快速幂运算
我们设定：$m=[\frac{n}{2}]$

* 当n为偶数: $A^{N}=A^{m}∗A^{m}$
* 当n为奇数: $A^{N}=A^{m}∗A^{m}∗A$

    相当于$A^{6}=A^3∗A^3，A^7=A^3∗A^3∗A$

$$T(n)=T(n/2)+\Theta(1)$$
套用Master公式，可得：
$$T(n)=\Theta(\log_2 n)$$

#### 5. 矩阵乘法
使用分治法，将矩阵分块，进行分块相乘，这种复杂度$\Theta(n^3)$
Strassen 提出了新的解法
$$T(n)=7T(n/2)+\Theta(n^2)$$
根据主定理求解：
$$T(n)=\Theta(n^{\log_2 7})$$







